import makeWASocket, {
  useMultiFileAuthState,
  DisconnectReason,
  fetchLatestBaileysVersion
} from '@whiskeysockets/baileys'
import Pino from 'pino'
import mongoose from 'mongoose'
import dotenv from 'dotenv'

dotenv.config()

/* ================= BASIC CONFIG ================= */

const OWNER_JIDS = ['94727114552@s.whatsapp.net']
const BOT_NUMBER = '94727114552' // pairing use only
const PREFIXES = ['!', '.', '/', '=']
const SESSION_NAME = 'sessions'

const MONGO_URI =
  'mongodb+srv://pahan:pahan@bot.e2zjn1x.mongodb.net/?appName=Bot'

const STATUS_VIEW = true
const STATUS_REACT = true

/* ================= MONGO ================= */

async function connectMongo() {
  try {
    await mongoose.connect(MONGO_URI)
    console.log('‚úÖ MongoDB connected')
  } catch (e) {
    console.log('‚ùå MongoDB error', e)
  }
}

/* ================= BOT START ================= */

async function startBot() {
  await connectMongo()

  const { state, saveCreds } =
    await useMultiFileAuthState(SESSION_NAME)

  const { version } = await fetchLatestBaileysVersion()

  const sock = makeWASocket({
    version,
    auth: state,
    logger: Pino({ level: 'silent' }),
    printQRInTerminal: true // QR auto if needed
  })

  sock.ev.on('creds.update', saveCreds)

  /* ===== AUTO PAIRING (IF NOT REGISTERED) ===== */
  if (!state.creds.registered) {
    try {
      const code = await sock.requestPairingCode(BOT_NUMBER)
      console.log('üîó Pairing Code:', code)
      console.log('üëâ WhatsApp > Linked Devices > Link with phone number')
    } catch (e) {
      // QR will handle automatically
    }
  }

  /* ================= MESSAGE HANDLER ================= */

  sock.ev.on('messages.upsert', async ({ messages }) => {
    const m = messages[0]
    if (!m.message) return

    const from = m.key.remoteJid
    const sender = m.key.participant || from

    const body =
      m.message.conversation ||
      m.message.extendedTextMessage?.text ||
      ''

    /* ===== STATUS VIEW + REACT ===== */
    if (from === 'status@broadcast') {
      if (STATUS_VIEW) {
        await sock.readMessages([m.key])
      }
      if (STATUS_REACT) {
        setTimeout(async () => {
          const reacts = ['‚ù§Ô∏è', 'üî•', 'üòÇ']
          await sock.sendMessage(from, {
            react: {
              text: reacts[Math.floor(Math.random() * reacts.length)],
              key: m.key
            }
          })
        }, 15000)
      }
      return
    }

    /* ===== COMMAND CHECK ===== */
    const prefix = PREFIXES.find(p => body.startsWith(p))
    if (!prefix) return

    const args = body.slice(prefix.length).trim().split(/\s+/)
    const command = args.shift().toLowerCase()
    const isOwner = OWNER_JIDS.includes(sender)

    const reply = txt =>
      sock.sendMessage(from, { text: txt }, { quoted: m })

    /* ===== COMMANDS ===== */

    if (command === 'ping') {
      reply('üèì Pong! Bot Alive')
    }

    if (command === 'menu') {
      reply(`ü§ñ BOT MENU

!ping
!menu
!owner
`)
    }

    if (command === 'owner') {
      if (!isOwner) return reply('‚ùå Owner only')
      reply('üëë Yes, you are the owner')
    }
  })

  /* ================= CONNECTION ================= */

  sock.ev.on('connection.update', ({ connection, lastDisconnect }) => {
    if (connection === 'open') {
      console.log('‚úÖ Bot connected & session saved')
    }
    if (connection === 'close') {
      if (
        lastDisconnect?.error?.output?.statusCode !==
        DisconnectReason.loggedOut
      ) {
        startBot()
      } else {
        console.log('‚ùå Logged out, delete session to re-pair')
      }
    }
  })
}

startBot()
